---
title: 【IC设计】NoC路由算法（整理自On-Chip Communication Architectures System on Chip Interconnect）
date: 2026-01-11 15:30:00
categories: IC设计
tags: [IC设计]
layout: post
---
﻿@[TOC]
# 路由算法（Routing Algorithm）
路由算法负责正确和高效地从源到目的地路由数据包。一个路由算法的选择是若干个冲突指标的权衡，例如路由的功耗最小化，逻辑和路由表的面积最小化，通过减少延时和最大化网络的流量利用率提高性能，改善健壮性去更好地适应变化的流量需求。
路由方案可以大致分为若干个类别，例如静态或者动态路由，

## i)静态和动态路由：
在NoC路由器中的路由决策要么是静态的（也称为确定性的），要么是动态地（也称为适应性的）。
### 静态路由
静态路由指的是在源和目的路由器之间的传输路径是固定的。这个路由方案不考虑网络的当前状态，并且在作出路由决策时对路由器和链路的负载情况是不考虑的。静态路由的优点是易于实现，因为它只需要非常少的路由逻辑。静态路由也允许数据包被分为多条路径进行传输，以一种预定义的方式。如果只有一条路径被选择，静态路由通常保证**按照数据包的顺序传输**。这消除了在NI处正确地辨认并重拍的需要。

**静态路由算法的例子包括：**
dimension order routing (DOR) [10], XY [17], pseudo-adaptive XY [17], surrounding XY [18], turn model (west-fi rst, north-last, negative-first) [19], Valiant ’s random [10], ALOAS [20], topology adaptive [21], probabilistic fl ood [22], source [23], destination tag [10], directed flood [22], and random walk routing [22]. 
### 动态路由
路由决策根据当前网络的状态做出，考虑因素有链路的可用性与负载。因此，随着时间的推进，在源和目的之间的路径根据流量情况来变化是可能的。这种适应性行为带来了持续监控网络和动态改变路由选择的开销。尽管如此，动态路由能够更好地在网络中分配流量，这也允许在相同的NoC拓扑上**支持更多的流量。**
通常，静态路由被用于流量稳定且预先知道的情况，而流量不规则、不可预测时，动态路由更加可取。

**动态路由的例子包括：**
minimal adaptive [10], fully adaptive [10], congestion look-ahead [24], turnaround–turnback [13], turnback when possible [19], IVAL [19], 2TURN [19], Q [25], odd–even [26], slack time aware [27], and hot potato routing [28].

## ii)分布式和源路由：
根据路由信息存储的地方，以及路由决策做出的地方，路由算法可以分类为分布式（distributed）路由和源（source）路由。

### 分布式路由
**在分布式路由（distributed routing）中**，每个包携带目的地址（例如，XY坐标或者目的节点/路由器的编号），路由决策在每个路由器中通过查找路由表中的目的地址或执行硬件函数**做出**。
因此每个路由器可以被认为实现了一个函数，即：函数的输入是包的目的地址，函数的输出是路由决策。当一个包抵达路由器的输入端口时，路由表被查询（或路由逻辑被执行）来根据目的地址决定包从哪个端口输出。

### 源路由
**在源路由中**，预计算的路由表被存储在了节点的（或者说PE的）NI中。当一个源节点传输一个数据包时，路由信息在源路由器基于目的地址被查询，并且该信息被添加到包的头部。因此每个包在其头部携带了路径上每一跳（hop）的路由选择信息。当一个包到达路由器时，这个路由选择信息就从包头部的路由部分提取出来。不同于分布式路由，源路由并没有要求包中有目的地址信息，任何中间的路由表或者需要去执行路由的函数。然而，源路由需要额外的路由信息在包的头部，并且随着路由长度的增加，比特数量会变多。每个源需要带有特定项的路由表。

**总结：**
分布式路由指的是数据包传递到的每个路由器后，由该路由器决定下一个路由器是谁，即路由决策是一次次做出来的。
源路由指的是，A路由器要传数据包给B，那么A直接给出完整的路由路径，封装到包头，到达每个路由器时，路由器通过包头信息就知道下一跳是谁。

## iii)最短和非最短的路由
另一种区分路由方案的分类方法是分为最短距离路由和非最短距离路由。
如果从源到目的的路由长度是最短的，那么这个路由算法是最短路由。
### 最短路由
例如在网格NoC拓扑中（在网格中，每个节点可以被网格的XY坐标所标识），如果源节点在(0,0)，目的节点在(i,j)，然后最短路径长度就是|i|+|j|。在最短路由中，如果最短路由链路是不可用的，源路由器不会发送包。
### 非最短路由
相反，非最短路由方案没有这样的约束，如果最短路径不可用，可以使用更长的路径。通过允许非最短路径，可替代的路径数增长了，这对于避免阻塞是有用的。
然而，非最短路由可能会在NoC中产生不希望的额外功耗开销。

# 设计路由算法要注意的问题
## 死锁
一个路由算法通常要负责确保在包交换NoC中不存在死锁。死锁发生在包在网络中被阻塞、且无限等待一个不可能发生的事件。当一个微片（flit）在相邻路由器之间传输时，它会释放第一个路由器的缓存，并占用下一个路由器的缓存。如果下一个路由器缓存已经占用了，这个微片就必须在第一个路由器的缓存等待下一个路由器缓存释放。在虫洞交换中，由于只有很少的缓存资源，死锁情况并不罕见。
死锁避免策略被用于分析是否这个路由算法的选择对于特定NoC拓扑会造成潜在的死锁，并且如果造成死锁，那么要么添加硬件资源、要么增加限制，以避免死锁产生。通常，将构建共享网络资源的依赖图进行静态或动态分析，已确定存在死锁条件时的路由限制。

## 活锁
类似地，活锁指的是除了资源状态不断变换，其余并没有实质性进展的传输，尤其是在使用自适应路由时会考虑网络状态，在一个输出端口处于繁忙状态时（对应链路无法使用），会选择另一个端口进行输出，由于在该方案的路由器中没有额外的缓存来存储包，每个包会在路由器之间反复跳转，如同烫手山芋（hot potato），但从未到达目的地。这种活锁机制通常可以用简单的优先级规则来避免。

## 饥饿
最终，除了死锁和活锁，饥饿是NoC的另一个问题。在包存在优先级的情况下，有些低优先级的包可能永远不会到达他们的目的地。这会在路由算法允许高优先级包无需检查就始终保留资源的情况下发生。通过使用公平的路由算法，或为低优先级的数据包保留一些带宽，可以避免饥饿。

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析 | 潘业成的博客</title><meta name="author" content="TDppy"><meta name="copyright" content="TDppy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概要main.c中引入了types.h&#x2F;param.h&#x2F;memlayout.h&#x2F;riscv.h&#x2F;defs.h头文件，各文件主要功能如下： 123456789101112131415161718192021&#x2F;&#x2F; 数据类型重命名:&#x2F;&#x2F; uint&#x2F;ushort&#x2F;uchar&#x2F;uint8&#x2F;uint16&#x2F;uint32&#x2F;uint64&#x2F;pde_t 的定义#include &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析">
<meta property="og:url" content="https://www.whyc.fun/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/index.html">
<meta property="og:site_name" content="潘业成的博客">
<meta property="og:description" content="概要main.c中引入了types.h&#x2F;param.h&#x2F;memlayout.h&#x2F;riscv.h&#x2F;defs.h头文件，各文件主要功能如下： 123456789101112131415161718192021&#x2F;&#x2F; 数据类型重命名:&#x2F;&#x2F; uint&#x2F;ushort&#x2F;uchar&#x2F;uint8&#x2F;uint16&#x2F;uint32&#x2F;uint64&#x2F;pde_t 的定义#include &amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.whyc.fun/img/butterfly-icon.png">
<meta property="article:published_time" content="2026-01-06T23:02:58.000Z">
<meta property="article:modified_time" content="2026-01-18T08:18:03.200Z">
<meta property="article:author" content="TDppy">
<meta property="article:tag" content="教学操作系统">
<meta property="article:tag" content="xv6">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.whyc.fun/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析",
  "url": "https://www.whyc.fun/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/",
  "image": "https://www.whyc.fun/img/butterfly-icon.png",
  "datePublished": "2026-01-06T23:02:58.000Z",
  "dateModified": "2026-01-18T08:18:03.200Z",
  "author": [
    {
      "@type": "Person",
      "name": "TDppy",
      "url": "https://www.whyc.fun"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.whyc.fun/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(https://oss.012700.xyz/butterfly/2024/10/index.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://oss.012700.xyz/butterfly/2024/10/index.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">潘业成的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-06T23:02:58.000Z" title="发表于 2026-01-06 23:02:58">2026-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-18T08:18:03.200Z" title="更新于 2026-01-18 08:18:03">2026-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>main.c中引入了types.h&#x2F;param.h&#x2F;memlayout.h&#x2F;riscv.h&#x2F;defs.h头文件，各文件主要功能如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型重命名:</span></span><br><span class="line"><span class="comment">// uint/ushort/uchar/uint8/uint16/uint32/uint64/pde_t 的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数定义:</span></span><br><span class="line"><span class="comment">// params.h 通过一系列宏定义，统一指定了操作系统内核中进程、CPU、文件、设备、文件系统等核心模块的最大值，</span></span><br><span class="line"><span class="comment">// 为内核各功能模块的运行提供统一的参数配置依据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存布局:</span></span><br><span class="line"><span class="comment">// 定义QEMU virt平台下RISC-V架构的物理内存（硬件设备、内核RAM）与虚拟内存（内核栈、用户空间、trampoline/trapframe）布局，</span></span><br><span class="line"><span class="comment">// 以及中断控制器等硬件地址常量，为内核内存管理和硬件交互提供地址映射依据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编语句:</span></span><br><span class="line"><span class="comment">// 定义一系列asm volatile汇编语句以及和MMU相关的宏，辅助简化代码编写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明:</span></span><br><span class="line"><span class="comment">// 定义了所有函数和结构体的声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="memlayout-h"><a href="#memlayout-h" class="headerlink" title="memlayout.h"></a>memlayout.h</h1><p><code>memlayout.h</code> 是 XV6 操作系统内核中定义内存布局的关键头文件，它规定了物理内存和虚拟内存的组织结构。需要注意的是，xv6是运行在QEMU virt仿真平台上的。<br>以下是对该文件的详细讲解：</p>
<h2 id="1-物理内存布局"><a href="#1-物理内存布局" class="headerlink" title="1. 物理内存布局"></a>1. 物理内存布局</h2><p>文件开头注释详细描述了 QEMU 虚拟 RISC-V 机器的物理内存布局：</p>
<table>
<thead>
<tr>
<th>物理地址范围</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>0x00001000</td>
<td>启动 ROM，由 QEMU 提供</td>
</tr>
<tr>
<td>0x02000000</td>
<td>CLINT (Core Local Interruptor)</td>
</tr>
<tr>
<td>0x0C000000</td>
<td>PLIC (Platform Level Interrupt Controller)</td>
</tr>
<tr>
<td>0x10000000</td>
<td>UART0 串口设备</td>
</tr>
<tr>
<td>0x10001000</td>
<td>VirtIO 磁盘设备</td>
</tr>
<tr>
<td>0x80000000</td>
<td>内核文件加载地址，QEMU -kernel会将_entry.S加载到0x80000000，0x80000000是CPU执行的起始地址</td>
</tr>
</tbody></table>
<h2 id="2-设备寄存器定义"><a href="#2-设备寄存器定义" class="headerlink" title="2. 设备寄存器定义"></a>2. 设备寄存器定义</h2><p>文件定义了各种设备寄存器的物理地址：</p>
<h3 id="UART-串口"><a href="#UART-串口" class="headerlink" title="UART 串口"></a>UART 串口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br></pre></td></tr></table></figure>
<h3 id="VirtIO-磁盘"><a href="#VirtIO-磁盘" class="headerlink" title="VirtIO 磁盘"></a>VirtIO 磁盘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br></pre></td></tr></table></figure>
<h3 id="CLINT-核心本地中断控制器）"><a href="#CLINT-核心本地中断控制器）" class="headerlink" title="CLINT (核心本地中断控制器）"></a>CLINT (核心本地中断控制器）</h3><p>**CLINT (Core Local Interrupt Controller)**是RISC-V架构中的一个关键组件：</p>
<ul>
<li>位于物理地址<code>0x02000000</code>（由<code>#define CLINT 0x2000000L</code>定义）</li>
<li>负责处理每个CPU核心(hart)的<strong>本地中断</strong></li>
<li>主要功能包括<strong>软件中断</strong>和<strong>定时器中断</strong>管理</li>
</ul>
<h4 id="定时器比较寄存器-CLINT-MTIMECMP"><a href="#定时器比较寄存器-CLINT-MTIMECMP" class="headerlink" title="定时器比较寄存器 (CLINT_MTIMECMP)"></a>定时器比较寄存器 (CLINT_MTIMECMP)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid)) <span class="comment">// 定时器比较寄存器</span></span></span><br></pre></td></tr></table></figure>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul>
<li><strong>作用</strong>：设置定时器中断的触发时间点</li>
<li><strong>特性</strong>：每个CPU核心(hart)都有独立的比较寄存器</li>
<li><strong>工作原理</strong>：当全局定时器<code>CLINT_MTIME</code>的值达到<code>CLINT_MTIMECMP</code>设置的值时，会触发相应核心的定时器中断</li>
</ul>
<h5 id="宏定义解析"><a href="#宏定义解析" class="headerlink" title="宏定义解析"></a>宏定义解析</h5><ul>
<li><code>CLINT</code>：基地址(0x2000000)</li>
<li><code>0x4000</code>：CLINT中定时器比较寄存器组的起始偏移</li>
<li><code>8*(hartid)</code>：每个比较寄存器占8字节(64位)，根据核心ID计算特定核心的寄存器地址</li>
</ul>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>在<code>start.c</code>的<code>timerinit()</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置定时器中断触发时间（当前时间 + 1000000个时钟周期）</span></span><br><span class="line">*(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br></pre></td></tr></table></figure>
<h4 id="全局定时器寄存器-CLINT-MTIME"><a href="#全局定时器寄存器-CLINT-MTIME" class="headerlink" title="全局定时器寄存器 (CLINT_MTIME)"></a>全局定时器寄存器 (CLINT_MTIME)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// 自启动以来的时钟周期计数</span></span></span><br></pre></td></tr></table></figure>
<h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><ul>
<li><strong>作用</strong>：记录系统自启动以来的<strong>总时钟周期数</strong></li>
<li><strong>特性</strong>：所有CPU核心共享同一个MTIME寄存器</li>
<li><strong>精度</strong>：64位无符号整数，确保长时间运行不会溢出</li>
</ul>
<h5 id="宏定义解析-1"><a href="#宏定义解析-1" class="headerlink" title="宏定义解析"></a>宏定义解析</h5><ul>
<li><code>CLINT</code>：基地址(0x2000000)</li>
<li><code>0xBFF8</code>：全局定时器寄存器在CLINT中的偏移地址</li>
</ul>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li>系统启动时自动开始计数</li>
<li>计数频率由硬件时钟决定（在QEMU中约为10MHz）</li>
<li>通过读取该寄存器可以获取系统运行时间</li>
</ul>
<h4 id="定时器中断工作流程"><a href="#定时器中断工作流程" class="headerlink" title="定时器中断工作流程"></a>定时器中断工作流程</h4><p>XV6系统中，定时器中断的完整工作流程如下：</p>
<ol>
<li><strong>初始化</strong>：在<code>start.c</code>的<code>timerinit()</code>中设置初始的比较值</li>
<li><strong>计时</strong>：<code>CLINT_MTIME</code>持续递增</li>
<li><strong>触发中断</strong>：当<code>CLINT_MTIME &gt;= CLINT_MTIMECMP(hartid)</code>时：<ul>
<li>CLINT向对应核心发送定时器中断请求</li>
<li>中断由<code>kernelvec.S</code>中的<code>timervec</code>处理</li>
<li>最终转换为软件中断，由<code>trap.c</code>中的<code>devintr()</code>处理</li>
</ul>
</li>
<li><strong>重置定时器</strong>：中断处理完成后，重新设置<code>CLINT_MTIMECMP</code>为当前时间 + 间隔</li>
</ol>
<h3 id="PLIC-平台级中断控制器"><a href="#PLIC-平台级中断控制器" class="headerlink" title="PLIC (平台级中断控制器)"></a>PLIC (平台级中断控制器)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="comment">// PLIC 相关寄存器地址定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100) <span class="comment">// 机器模式使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100) <span class="comment">// 监管者模式使能</span></span></span><br><span class="line"><span class="comment">// 更多 PLIC 寄存器...</span></span><br></pre></td></tr></table></figure>

<h4 id="1-优先级寄存器组-PLIC-PRIORITY"><a href="#1-优先级寄存器组-PLIC-PRIORITY" class="headerlink" title="1. 优先级寄存器组 (PLIC_PRIORITY)"></a>1. 优先级寄存器组 (PLIC_PRIORITY)</h4><p><strong>地址</strong>：<code>PLIC + 0x0</code><br><strong>格式</strong>：32位寄存器数组，每个中断源占用一个4字节寄存器<br><strong>范围</strong>：中断源0~1023，但XV6中主要使用UART0_IRQ(10)和VIRTIO0_IRQ(1)</p>
<p><strong>功能</strong>：</p>
<ul>
<li>为每个中断源设置优先级（0~7）</li>
<li>优先级0表示禁用该中断</li>
<li>数字越大，优先级越高</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在plicinit()中设置UART和VirtIO磁盘的中断优先级为1</span></span><br><span class="line">*(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">*(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-待处理中断寄存器-PLIC-PENDING"><a href="#2-待处理中断寄存器-PLIC-PENDING" class="headerlink" title="2. 待处理中断寄存器 (PLIC_PENDING)"></a>2. 待处理中断寄存器 (PLIC_PENDING)</h4><p><strong>地址</strong>：<code>PLIC + 0x1000</code><br><strong>格式</strong>：多个32位寄存器，每位对应一个中断源<br><strong>范围</strong>：共1024个中断源，需要32个32位寄存器</p>
<p><strong>功能</strong>：</p>
<ul>
<li>指示哪些中断源有未处理的中断请求</li>
<li>第n位为1表示中断源n有未处理中断</li>
<li>只读寄存器，写操作无效</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>内核可以查询此寄存器了解当前待处理的中断</li>
<li>通常由PLIC硬件自动更新状态</li>
</ul>
<h4 id="3-中断使能寄存器组"><a href="#3-中断使能寄存器组" class="headerlink" title="3. 中断使能寄存器组"></a>3. 中断使能寄存器组</h4><h5 id="3-1-机器模式中断使能-PLIC-MENABLE"><a href="#3-1-机器模式中断使能-PLIC-MENABLE" class="headerlink" title="3.1 机器模式中断使能 (PLIC_MENABLE)"></a>3.1 机器模式中断使能 (PLIC_MENABLE)</h5><p><strong>地址</strong>：<code>PLIC + 0x2000 + (hart)*0x100</code><br><strong>格式</strong>：每个核心(hart)有一个64字节的使能寄存器组（16个32位寄存器）<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li>控制哪些中断源可以向特定核心的机器模式(M-mode)发送中断</li>
<li>第n位为1表示允许中断源n的中断</li>
</ul>
<h5 id="3-2-监管者模式中断使能-PLIC-SENABLE"><a href="#3-2-监管者模式中断使能-PLIC-SENABLE" class="headerlink" title="3.2 监管者模式中断使能 (PLIC_SENABLE)"></a>3.2 监管者模式中断使能 (PLIC_SENABLE)</h5><p><strong>地址</strong>：<code>PLIC + 0x2080 + (hart)*0x100</code><br><strong>格式</strong>：与PLIC_MENABLE相同<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li>控制哪些中断源可以向特定核心的监管者模式(S-mode)发送中断</li>
<li>第n位为1表示允许中断源n的中断</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在plicinithart()中启用UART和VirtIO磁盘的监管者模式中断</span></span><br><span class="line">*(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br></pre></td></tr></table></figure>

<h4 id="4-优先级阈值寄存器组"><a href="#4-优先级阈值寄存器组" class="headerlink" title="4. 优先级阈值寄存器组"></a>4. 优先级阈值寄存器组</h4><h5 id="4-1-机器模式优先级阈值-PLIC-MPRIORITY"><a href="#4-1-机器模式优先级阈值-PLIC-MPRIORITY" class="headerlink" title="4.1 机器模式优先级阈值 (PLIC_MPRIORITY)"></a>4.1 机器模式优先级阈值 (PLIC_MPRIORITY)</h5><p><strong>地址</strong>：<code>PLIC + 0x200000 + (hart)*0x2000</code><br><strong>格式</strong>：32位寄存器<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li>设置机器模式下中断处理的优先级阈值</li>
<li>只有优先级高于此阈值的中断才会被处理</li>
<li>值为0表示处理所有优先级&gt;0的中断</li>
<li>值为7表示不处理任何中断</li>
</ul>
<h5 id="4-2-监管者模式优先级阈值-PLIC-SPRIORITY"><a href="#4-2-监管者模式优先级阈值-PLIC-SPRIORITY" class="headerlink" title="4.2 监管者模式优先级阈值 (PLIC_SPRIORITY)"></a>4.2 监管者模式优先级阈值 (PLIC_SPRIORITY)</h5><p><strong>地址</strong>：<code>PLIC + 0x201000 + (hart)*0x2000</code><br><strong>格式</strong>：与PLIC_MPRIORITY相同<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li>设置监管者模式下中断处理的优先级阈值</li>
<li>只有优先级高于此阈值的中断才会被处理</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在plicinithart()中设置监管者模式的优先级阈值为0</span></span><br><span class="line"><span class="comment">// 表示处理所有优先级&gt;0的中断</span></span><br><span class="line">*(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-中断认领和完成寄存器组"><a href="#5-中断认领和完成寄存器组" class="headerlink" title="5. 中断认领和完成寄存器组"></a>5. 中断认领和完成寄存器组</h4><h5 id="5-1-机器模式中断认领-PLIC-MCLAIM"><a href="#5-1-机器模式中断认领-PLIC-MCLAIM" class="headerlink" title="5.1 机器模式中断认领 (PLIC_MCLAIM)"></a>5.1 机器模式中断认领 (PLIC_MCLAIM)</h5><p><strong>地址</strong>：<code>PLIC + 0x200004 + (hart)*0x2000</code><br><strong>格式</strong>：32位寄存器<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>读操作</strong>：返回当前优先级最高的待处理中断ID，同时清除该中断的待处理状态</li>
<li><strong>写操作</strong>：将中断ID写回，表示该中断处理完成</li>
</ul>
<h5 id="5-2-监管者模式中断认领-PLIC-SCLAIM"><a href="#5-2-监管者模式中断认领-PLIC-SCLAIM" class="headerlink" title="5.2 监管者模式中断认领 (PLIC_SCLAIM)"></a>5.2 监管者模式中断认领 (PLIC_SCLAIM)</h5><p><strong>地址</strong>：<code>PLIC + 0x201004 + (hart)*0x2000</code><br><strong>格式</strong>：与PLIC_MCLAIM相同<br><strong>参数</strong>：<code>hart</code> - CPU核心ID</p>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>读操作</strong>：返回当前优先级最高的待处理中断ID，同时清除该中断的待处理状态</li>
<li><strong>写操作</strong>：将中断ID写回，表示该中断处理完成</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在plic_claim()中认领一个中断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在plic_complete()中完成中断处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">plic_complete</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  *(uint32*)PLIC_SCLAIM(hart) = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PLIC-工作流程"><a href="#PLIC-工作流程" class="headerlink" title="PLIC 工作流程"></a>PLIC 工作流程</h4><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>设置中断源优先级（<code>plicinit()</code>）</li>
<li>配置中断使能和优先级阈值（<code>plicinithart()</code>）</li>
</ul>
</li>
<li><p><strong>中断发生</strong>：</p>
<ul>
<li>外设产生中断请求</li>
<li>PLIC检测到中断，设置对应的待处理位</li>
<li>如果中断优先级高于阈值且已使能，则向CPU发送中断信号</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>CPU进入中断处理模式</li>
<li>调用<code>plic_claim()</code>认领优先级最高的中断</li>
<li>处理具体的中断事件</li>
<li>调用<code>plic_complete()</code>通知PLIC中断处理完成</li>
</ul>
</li>
<li><p><strong>中断完成</strong>：</p>
<ul>
<li>PLIC清除中断的待处理状态</li>
<li>可以接收下一个中断请求</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>PLIC (Platform Level Interrupt Controller) 是RISC-V架构中负责管理外部中断的核心组件，通过灵活的优先级控制和中断路由机制，实现了多核心系统中的中断管理。XV6操作系统主要使用监管者模式(S-mode)的PLIC功能，通过上述寄存器组实现了对UART串口和VirtIO磁盘等外设中断的管理。这种设计使得操作系统能够有效地处理各种外设中断，提高系统的响应性和并发处理能力。</p>
<h3 id="3-内核内存布局"><a href="#3-内核内存布局" class="headerlink" title="3. 内核内存布局"></a>3. 内核内存布局</h3><h4 id="内核基地址和物理内存上限"><a href="#内核基地址和物理内存上限" class="headerlink" title="内核基地址和物理内存上限"></a>内核基地址和物理内存上限</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L  <span class="comment">// 内核在物理内存中的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024) <span class="comment">// 物理内存上限 (128MB)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="特殊内存区域"><a href="#特殊内存区域" class="headerlink" title="特殊内存区域"></a>特殊内存区域</h4><h5 id="1-Trampoline-页面"><a href="#1-Trampoline-页面" class="headerlink" title="1. Trampoline 页面"></a>1. Trampoline 页面</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE) <span class="comment">// 映射到最高地址，用户和内核空间共享</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>位置</strong>：虚拟地址空间的最高一页</li>
<li><strong>作用</strong>：用于在用户模式和内核模式之间切换（陷阱处理）</li>
<li><strong>特性</strong>：在用户和内核空间中映射到相同的物理页面</li>
</ul>
<h5 id="2-内核栈"><a href="#2-内核栈" class="headerlink" title="2. 内核栈"></a>2. 内核栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE) <span class="comment">// 每个进程的内核栈</span></span></span><br></pre></td></tr></table></figure>
<p>从 KSTACK(p) 宏的计算方式可以看出：每个进程的内核栈分配 2*PGSIZE （8KB，假设 PGSIZE&#x3D;4KB）的虚拟地址空间，但实际上只使用其中 1个PGSIZE 作为实际的栈空间，另一个PGSIZE作为 未映射的保护页。</p>
<ul>
<li><strong>位置</strong>：Trampoline 页面下方</li>
<li><strong>布局</strong>：每个进程的内核栈大小为 1 页，前后各有一个无效的保护页</li>
<li><strong>作用</strong>：进程在内核模式下执行时使用的栈</li>
</ul>
<h5 id="3-Trapframe"><a href="#3-Trapframe" class="headerlink" title="3. Trapframe"></a>3. Trapframe</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE) <span class="comment">// 用户陷阱帧位置</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>位置</strong>：Trampoline 页面下方紧挨着的一页</li>
<li><strong>作用</strong>：保存用户进程在发生陷阱时的寄存器状态</li>
</ul>
<h3 id="4-用户内存布局"><a href="#4-用户内存布局" class="headerlink" title="4. 用户内存布局"></a>4. 用户内存布局</h3><p>用户进程的虚拟内存布局从地址 0 开始，向上依次为：</p>
<ol>
<li><strong>代码段 (text)</strong>：程序的可执行代码</li>
<li><strong>数据段和 BSS 段</strong>：初始化和未初始化的数据</li>
<li><strong>固定大小的栈</strong>：用户进程的栈空间</li>
<li><strong>可扩展的堆</strong>：动态内存分配区域</li>
<li><strong>…</strong>：中间是未分配的地址空间</li>
<li><strong>TRAPFRAME</strong>：用户陷阱帧（与内核共享的页面）</li>
<li><strong>TRAMPOLINE</strong>：trampoline 页面（与内核共享的页面）</li>
</ol>
<h4 id="关键依赖定义"><a href="#关键依赖定义" class="headerlink" title="关键依赖定义"></a>关键依赖定义</h4><p>虽然这些定义不在 <code>memlayout.h</code> 中，但它们对于理解内存布局至关重要：</p>
<h5 id="页面大小相关（来自-riscv-h）"><a href="#页面大小相关（来自-riscv-h）" class="headerlink" title="页面大小相关（来自 riscv.h）"></a>页面大小相关（来自 riscv.h）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// 页面大小 (4KB)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// 页面内偏移的位数</span></span></span><br></pre></td></tr></table></figure>

<h5 id="虚拟地址空间上限（来自-riscv-h）"><a href="#虚拟地址空间上限（来自-riscv-h）" class="headerlink" title="虚拟地址空间上限（来自 riscv.h）"></a>虚拟地址空间上限（来自 riscv.h）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1)) <span class="comment">// 虚拟地址空间上限 (~512GB)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>基于 RISC-V Sv39 页表方案</li>
<li>39 位虚拟地址：9位(页目录) + 9位(页表) + 9位(页表) + 12位(页内偏移)</li>
</ul>
<h4 id="内存布局设计特点"><a href="#内存布局设计特点" class="headerlink" title="内存布局设计特点"></a>内存布局设计特点</h4><ol>
<li><strong>分离的内核和用户空间</strong>：内核占据高地址，用户进程占据低地址</li>
<li><strong>共享的 trampoline 页面</strong>：实现用户&#x2F;内核模式切换的关键</li>
<li><strong>保护页机制</strong>：内核栈前后各有一个无效页面，防止栈溢出</li>
<li><strong>固定的布局</strong>：关键内存区域的位置固定，便于内核管理</li>
</ol>
<h4 id="与其他文件的关系"><a href="#与其他文件的关系" class="headerlink" title="与其他文件的关系"></a>与其他文件的关系</h4><ul>
<li><strong>riscv.h</strong>：提供页面大小、虚拟地址上限等基础定义</li>
<li><strong>kernel.ld</strong>：定义内核代码、数据等段的链接布局</li>
<li><strong>vm.c</strong>：使用这些定义进行页表管理和地址转换</li>
<li><strong>proc.c</strong>：使用这些定义为进程分配内核栈和陷阱帧</li>
</ul>
<p><code>memlayout.h</code> 作为内存布局的蓝图，为 XV6 操作系统的内存管理提供了清晰的框架，确保了内核和用户进程能够安全、高效地访问内存资源。</p>
<h1 id="riscv-h"><a href="#riscv-h" class="headerlink" title="riscv.h"></a>riscv.h</h1><h2 id="1-文件概述"><a href="#1-文件概述" class="headerlink" title="1. 文件概述"></a>1. 文件概述</h2><p><code>riscv.h</code> 是 XV6 操作系统中用于定义 RISC-V 架构相关常量、宏和内联函数的头文件，主要提供了以下功能：</p>
<ul>
<li>RISC-V 控制状态寄存器 (CSR) 的读写操作</li>
<li>内存分页机制相关的常量和宏定义</li>
<li>中断控制函数</li>
<li>页表数据结构定义</li>
</ul>
<h2 id="2-控制状态寄存器-CSR-操作"><a href="#2-控制状态寄存器-CSR-操作" class="headerlink" title="2. 控制状态寄存器 (CSR) 操作"></a>2. 控制状态寄存器 (CSR) 操作</h2><h3 id="2-1-核心寄存器读写"><a href="#2-1-核心寄存器读写" class="headerlink" title="2.1 核心寄存器读写"></a>2.1 核心寄存器读写</h3><p>该部分定义了一系列内联函数，用于读写 RISC-V 架构的核心控制状态寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取当前核心ID</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_mhartid</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 机器模式状态寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_mstatus</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_mstatus</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监管者模式状态寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sstatus</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sstatus</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监管者中断使能寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sie</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sie</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监管者异常程序计数器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sepc</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sepc</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监管者页表寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_satp</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_satp</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这些函数使用 RISC-V 的 <code>csrr</code>（读 CSR）和 <code>csrw</code>（写 CSR）指令实现对寄存器的访问。</p>
<h3 id="2-2-寄存器位掩码定义"><a href="#2-2-寄存器位掩码定义" class="headerlink" title="2.2 寄存器位掩码定义"></a>2.2 寄存器位掩码定义</h3><p>为了方便操作寄存器的特定位，定义了一系列位掩码常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 机器模式状态寄存器位掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_MASK (3L &lt;&lt; 11) <span class="comment">// 前一个模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_M (3L &lt;&lt; 11)    <span class="comment">// 机器模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_S (1L &lt;&lt; 11)    <span class="comment">// 监管者模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_U (0L &lt;&lt; 11)    <span class="comment">// 用户模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MIE (1L &lt;&lt; 3)       <span class="comment">// 机器模式中断使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监管者模式状态寄存器位掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP (1L &lt;&lt; 8)       <span class="comment">// 前一个模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE (1L &lt;&lt; 5)      <span class="comment">// 监管者前中断使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE (1L &lt;&lt; 1)       <span class="comment">// 监管者中断使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UIE (1L &lt;&lt; 0)       <span class="comment">// 用户中断使能</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-内存分页机制"><a href="#3-内存分页机制" class="headerlink" title="3. 内存分页机制"></a>3. 内存分页机制</h2><h3 id="3-1-页面基本定义"><a href="#3-1-页面基本定义" class="headerlink" title="3.1 页面基本定义"></a>3.1 页面基本定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096     <span class="comment">// 每页字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12      <span class="comment">// 页内偏移位数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上对齐到页边界(页内偏移为0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// 向下对齐到页边界</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-页表项-PTE-定义"><a href="#3-2-页表项-PTE-定义" class="headerlink" title="3.2 页表项 (PTE) 定义"></a>3.2 页表项 (PTE) 定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页表项标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// 有效位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1) <span class="comment">// 读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2) <span class="comment">// 写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3) <span class="comment">// 执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// 用户可访问</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理地址与页表项转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-页表索引提取"><a href="#3-3-页表索引提取" class="headerlink" title="3.3 页表索引提取"></a>3.3 页表索引提取</h3><p>针对 RISC-V 的 SV39 分页方案，定义了提取页表各级索引的宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9位索引掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure>

<p>SV39是RISC-V架构中39位虚拟地址的分页方案，它将虚拟地址划分为三个9位的页表索引和一个12位的页内偏移，总共3*9+12&#x3D;39位。虚拟地址从高位到低位依次是VPN[2]（第2级页表索引，9位）、VPN[1]（第1级页表索引，9位）、VPN[0]（第0级页表索引，9位）和offset（页内偏移，12位）。这种三级页表结构允许系统支持最大512GB的虚拟地址空间（2^39字节）。</p>
<p>在riscv.h中，PX、PXSHIFT和PXMASK这三个宏共同实现了从虚拟地址中提取各级页表索引的功能。首先，PXMASK定义为0x1FF（二进制111111111），这是一个9位的掩码，用于从虚拟地址中精确提取出9位的页表索引部分。</p>
<p>PXSHIFT宏用于计算特定级别页表索引在虚拟地址中的位偏移量。它的计算公式是PGSHIFT+(9*(level))，其中PGSHIFT是12，表示页内偏移的位数。对于第0级页表索引（最低级），偏移量是12+0&#x3D;12位，意味着需要将虚拟地址右移12位才能将VPN[0]移到最低位。对于第1级页表索引，偏移量是12+9&#x3D;21位，需要右移21位。对于第2级页表索引（最高级），偏移量是12+18&#x3D;30位，需要右移30位。</p>
<p>PX宏则是实际用于提取页表索引的工具，它接收两个参数：level（页表级别）和va（虚拟地址）。它首先将虚拟地址转换为64位无符号整数，然后向右移动PXSHIFT(level)位，将目标页表索引移到最低位，最后与PXMASK进行按位与操作，这样就得到了9位的页表索引值。</p>
<p>在实际的页表遍历过程中，操作系统会首先使用satp寄存器找到虚拟地址的第2级页表根地址，然后PX(2, va)提取虚拟地址的第2级页表索引，用它在第2级页表中查找对应的页表项（PTE）。如果该PTE有效，则获取其指向的第1级页表的物理地址，然后使用PX(1, va)提取第1级页表索引，在第1级页表中查找对应的PTE。同样，如果有效，再获取其指向的第0级页表的物理地址，最后使用PX(0, va)提取第0级页表索引，在第0级页表中查找最终的PTE，该PTE包含了物理页面的基地址。将这个基地址与虚拟地址的页内偏移（va &amp; 0xFFF）相加，就得到了最终的物理地址。</p>
<p>这种分页方案通过三级页表结构实现了对大内存空间的高效管理，同时这些宏定义简化了从虚拟地址中提取各级页表索引的操作，使页表遍历代码更加清晰和高效。</p>
<h3 id="3-4-虚拟地址空间限制"><a href="#3-4-虚拟地址空间限制" class="headerlink" title="3.4 虚拟地址空间限制"></a>3.4 虚拟地址空间限制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大虚拟地址（比Sv39允许的最大值小一位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>

<h2 id="4-中断控制"><a href="#4-中断控制" class="headerlink" title="4. 中断控制"></a>4. 中断控制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_on</span><span class="params">()</span> &#123;</span><br><span class="line">  w_sstatus(r_sstatus() | SSTATUS_SIE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_off</span><span class="params">()</span> &#123;</span><br><span class="line">  w_sstatus(r_sstatus() &amp; ~SSTATUS_SIE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查设备中断是否启用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">intr_get</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  <span class="keyword">return</span> (x &amp; SSTATUS_SIE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-寄存器直接访问"><a href="#5-寄存器直接访问" class="headerlink" title="5. 寄存器直接访问"></a>5. 寄存器直接访问</h2><p>提供了直接访问通用寄存器的内联函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取栈指针</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sp</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取和写入线程指针（存储核心ID）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_tp</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_tp</span><span class="params">(uint64 x)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取返回地址寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_ra</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-地址转换辅助函数"><a href="#6-地址转换辅助函数" class="headerlink" title="6. 地址转换辅助函数"></a>6. 地址转换辅助函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新TLB</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sfence_vma</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// zero, zero 表示刷新所有TLB条目</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建SATP寄存器值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br></pre></td></tr></table></figure>

<h2 id="7-类型定义"><a href="#7-类型定义" class="headerlink" title="7. 类型定义"></a>7. 类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;           <span class="comment">// 页表项类型</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>;    <span class="comment">// 页表类型（512个PTE）</span></span><br></pre></td></tr></table></figure>

<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p><code>riscv.h</code> 是 XV6 操作系统中与 RISC-V 架构紧密相关的核心头文件，它提供了：</p>
<ul>
<li>对 RISC-V 控制状态寄存器的便捷访问接口</li>
<li>完整的内存分页机制支持</li>
<li>中断控制功能</li>
<li>核心寄存器的直接访问方法</li>
</ul>
<p>这些定义和函数为 XV6 内核的其他部分提供了与 RISC-V 硬件交互的基础，是理解 XV6 操作系统如何在 RISC-V 架构上运行的关键文件之一。</p>
<h1 id="defs-h"><a href="#defs-h" class="headerlink" title="defs.h"></a>defs.h</h1><h2 id="1-文件概述-1"><a href="#1-文件概述-1" class="headerlink" title="1. 文件概述"></a>1. 文件概述</h2><p>defs.h 是 XV6 操作系统内核中的一个核心头文件，主要用于统一声明内核各模块的函数原型和结构体前向声明，实现了内核模块间的接口定义和依赖管理。它的存在使得内核各模块可以相互调用函数而无需包含对方的完整头文件，减少了编译依赖，提高了代码的模块化程度。</p>
<h2 id="2-结构体前向声明"><a href="#2-结构体前向声明" class="headerlink" title="2. 结构体前向声明"></a>2. 结构体前向声明</h2><p>文件开头部分包含了一系列结构体的前向声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这些前向声明允许函数原型中使用这些结构体类型的指针，而无需包含完整的结构体定义，从而减少了头文件的依赖层级。</p>
<h2 id="3-函数原型声明"><a href="#3-函数原型声明" class="headerlink" title="3. 函数原型声明"></a>3. 函数原型声明</h2><p>defs.h 按功能模块组织了内核所有公共函数的原型声明，主要包括以下模块：</p>
<h3 id="3-1-块设备-I-O-bio-c"><a href="#3-1-块设备-I-O-bio-c" class="headerlink" title="3.1 块设备 I&#x2F;O (bio.c)"></a>3.1 块设备 I&#x2F;O (bio.c)</h3><p>声明了块设备缓冲管理相关的函数，如 <code>binit()</code>、<code>bread()</code>、<code>bwrite()</code> 等，用于管理磁盘 I&#x2F;O 操作的缓冲区。</p>
<h3 id="3-2-控制台-console-c"><a href="#3-2-控制台-console-c" class="headerlink" title="3.2 控制台 (console.c)"></a>3.2 控制台 (console.c)</h3><p>声明了控制台初始化和输入输出相关的函数，如 <code>consoleinit()</code>、<code>consoleintr()</code>、<code>consputc()</code> 等。</p>
<h3 id="3-3-进程执行-exec-c"><a href="#3-3-进程执行-exec-c" class="headerlink" title="3.3 进程执行 (exec.c)"></a>3.3 进程执行 (exec.c)</h3><p>声明了程序执行相关的函数，主要是 <code>exec()</code> 函数，用于加载和执行用户程序。</p>
<h3 id="3-4-文件系统-fs-c-file-c-pipe-c"><a href="#3-4-文件系统-fs-c-file-c-pipe-c" class="headerlink" title="3.4 文件系统 (fs.c, file.c, pipe.c)"></a>3.4 文件系统 (fs.c, file.c, pipe.c)</h3><p>包含了文件系统相关的函数，如 <code>fsinit()</code>、<code>dirlookup()</code>、<code>filealloc()</code>、<code>pipealloc()</code> 等，用于管理文件、目录和管道操作。</p>
<h3 id="3-5-内存管理-kalloc-c-vm-c"><a href="#3-5-内存管理-kalloc-c-vm-c" class="headerlink" title="3.5 内存管理 (kalloc.c, vm.c)"></a>3.5 内存管理 (kalloc.c, vm.c)</h3><p>声明了内存分配和虚拟内存管理相关的函数，如 <code>kalloc()</code>、<code>kfree()</code>、<code>kvmmap()</code>、<code>uvmalloc()</code> 等。</p>
<h3 id="3-6-进程管理-proc-c"><a href="#3-6-进程管理-proc-c" class="headerlink" title="3.6 进程管理 (proc.c)"></a>3.6 进程管理 (proc.c)</h3><p>包含了进程管理相关的函数，如 <code>fork()</code>、<code>exit()</code>、<code>scheduler()</code>、<code>sleep()</code>、<code>wakeup()</code> 等。</p>
<h3 id="3-7-其他核心模块"><a href="#3-7-其他核心模块" class="headerlink" title="3.7 其他核心模块"></a>3.7 其他核心模块</h3><p>还包括了日志系统 (log.c)、串口通信 (uart.c)、中断处理 (trap.c)、锁机制 (spinlock.c, sleeplock.c)、字符串处理 (string.c) 等模块的函数声明。</p>
<h2 id="4-通用宏定义"><a href="#4-通用宏定义" class="headerlink" title="4. 通用宏定义"></a>4. 通用宏定义</h2><p>文件末尾定义了一些通用的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NELEM(x) (sizeof(x)/sizeof((x)[0]))</span></span><br></pre></td></tr></table></figure>

<p>这个宏用于计算固定大小数组的元素个数，是 C 语言编程中常用的技巧。</p>
<h2 id="5-网络扩展-LAB-NET"><a href="#5-网络扩展-LAB-NET" class="headerlink" title="5. 网络扩展 (LAB_NET)"></a>5. 网络扩展 (LAB_NET)</h2><p>defs.h 还包含了条件编译的网络相关声明，当定义了 <code>LAB_NET</code> 宏时，会包含网络模块的结构体前向声明和函数原型，如网卡驱动 (e1000.c)、网络协议 (net.c) 和套接字 (sysnet.c) 等相关函数。</p>
<h2 id="6-作用与意义"><a href="#6-作用与意义" class="headerlink" title="6. 作用与意义"></a>6. 作用与意义</h2><p>defs.h 在 XV6 内核中扮演着”中央接口定义文件”的角色，它使得内核各模块可以清晰地了解其他模块提供的功能，而无需关心具体实现细节。这种设计提高了代码的模块化程度，便于维护和扩展。当内核需要添加新功能或修改现有功能时，通常只需要在相应的源文件中实现，并在 defs.h 中声明函数原型即可。</p>
<h1 id="types-h"><a href="#types-h" class="headerlink" title="types.h"></a>types.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> ushort;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> uint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  uint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> uint64;</span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pde_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="param-h"><a href="#param-h" class="headerlink" title="param.h"></a>param.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// param.h：xv6操作系统的参数配置文件，定义系统资源的最大限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROC        64  <span class="comment">// 系统支持的最大进程数（同时运行/存在的进程上限）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NCPU         8   <span class="comment">// 系统支持的最大CPU核心数（多处理器配置上限）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFILE       16  <span class="comment">// 单个进程可同时打开的最大文件数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILE        100 <span class="comment">// 整个系统可同时打开的最大文件数（所有进程共享）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINODE       50  <span class="comment">// 系统中活跃i-node的最大数量（i-node用于描述文件元信息）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEV         10  <span class="comment">// 系统支持的最大主设备号（标识不同硬件设备的编号上限）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTDEV      1   <span class="comment">// 根文件系统所在磁盘的设备号（xv6中通常对应第一个磁盘）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARG       32  <span class="comment">// 执行程序时允许的最大命令行参数个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// 文件系统操作（如读写）中允许的最大数据块数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE      (MAXOPBLOCKS*3) <span class="comment">// 磁盘日志区的最大数据块数（用于文件系统事务回滚）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBUF         (MAXOPBLOCKS*3) <span class="comment">// 磁盘块缓存的大小（缓存常用磁盘块，提升IO效率）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSSIZE       1000 <span class="comment">// 文件系统的总大小（单位：磁盘块）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATH      128  <span class="comment">// 文件路径名的最大长度（包含目录、文件名的完整路径字符数上限）</span></span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.whyc.fun">TDppy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.whyc.fun/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/">https://www.whyc.fun/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.whyc.fun" target="_blank">潘业成的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">教学操作系统</a><a class="post-meta__tags" href="/tags/xv6/">xv6</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/Q1/operating-system-what-happens-after-pressing-enter-in-xv6-operating-system/" title="【操作系统】xv6操作系统中按下键盘回车后发生的事情"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【操作系统】xv6操作系统中按下键盘回车后发生的事情</div></div><div class="info-2"><div class="info-item-1">xv6概述与学习价值xv6是麻省理工学院为MIT 6.S081操作系统课程设计的教学操作系统。总代码量约1万行，主要使用C语言编写，辅以少量汇编代码。它涵盖操作系统核心机制：进程调度、文件系统、中断处理、设备驱动等。 xv6基于Unix V6系统改进设计，”x”表示可扩展(eXtensible)。相比简单嵌入式OS如uC&#x2F;OS，xv6更接近现代操作系统架构。早期版本基于x86架构，2020年后推出RISC-V版本，本文分析该版本。 学习xv6的价值体现在多个方面：  深入理解系统实现：通过阅读和修改代码，掌握操作系统核心原理，包括：  I&#x2F;O机制：printf如何输出到屏幕 输入处理：键盘按键如何被捕获和处理 进程管理：操作系统如何调度和管理进程 软硬件接口：软件与硬件的交互方式   应聘技能提升：操作系统知识是嵌入式开发、固件开发、芯片运行时等岗位的核心要求，可以作为简历上的项目备战招聘。  系统设计思维培养：操作系统是典型的系统设计课程，我们需要了解其中的系统设计思想，为解决复杂问题提供思路。   本文通过分析按下键盘回车键后的完整执行流程，展示xv6的中...</div></div></div></a><a class="pagination-related" href="/2025/Q4/operating-system-hand-write-xv6-operating-system-entry-s-and-start-c-analysis/" title="【操作系统】手撸xv6操作系统——entry.S和start.c解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【操作系统】手撸xv6操作系统——entry.S和start.c解析</div></div><div class="info-2"><div class="info-item-1">entry.S解析和调试代码分析entry.S是xv6上电后执行的第一段代码，用于设置每个CPU的栈指针并跳转到start函数，每个CPU拥有4KB的栈空间。 123456789101112.section .text_entry:        la sp, stack0        li a0, 1024*4			 csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0	# jump to start() in start.c        call startspin:        j spin 整段代码的作用是令sp &#x3D; stack0的地址 + 4096 × (当前运行的CPU核心编号 + 1)。la sp,stack0，la是load address，将stack0的地址赋值到sp寄存器，在RISC-V架构中sp是栈指针寄存器。li a0,1024*4，li是load immediate，加载立即数4096到a0。csrr a1,mhartid，是...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/Q4/operating-system-hand-write-xv6-operating-system-entry-s-and-start-c-analysis/" title="【操作系统】手撸xv6操作系统——entry.S和start.c解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">【操作系统】手撸xv6操作系统——entry.S和start.c解析</div></div><div class="info-2"><div class="info-item-1">entry.S解析和调试代码分析entry.S是xv6上电后执行的第一段代码，用于设置每个CPU的栈指针并跳转到start函数，每个CPU拥有4KB的栈空间。 123456789101112.section .text_entry:        la sp, stack0        li a0, 1024*4			 csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0	# jump to start() in start.c        call startspin:        j spin 整段代码的作用是令sp &#x3D; stack0的地址 + 4096 × (当前运行的CPU核心编号 + 1)。la sp,stack0，la是load address，将stack0的地址赋值到sp寄存器，在RISC-V架构中sp是栈指针寄存器。li a0,1024*4，li是load immediate，加载立即数4096到a0。csrr a1,mhartid，是...</div></div></div></a><a class="pagination-related" href="/2026/Q1/operating-system-what-happens-after-pressing-enter-in-xv6-operating-system/" title="【操作系统】xv6操作系统中按下键盘回车后发生的事情"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-10</div><div class="info-item-2">【操作系统】xv6操作系统中按下键盘回车后发生的事情</div></div><div class="info-2"><div class="info-item-1">xv6概述与学习价值xv6是麻省理工学院为MIT 6.S081操作系统课程设计的教学操作系统。总代码量约1万行，主要使用C语言编写，辅以少量汇编代码。它涵盖操作系统核心机制：进程调度、文件系统、中断处理、设备驱动等。 xv6基于Unix V6系统改进设计，”x”表示可扩展(eXtensible)。相比简单嵌入式OS如uC&#x2F;OS，xv6更接近现代操作系统架构。早期版本基于x86架构，2020年后推出RISC-V版本，本文分析该版本。 学习xv6的价值体现在多个方面：  深入理解系统实现：通过阅读和修改代码，掌握操作系统核心原理，包括：  I&#x2F;O机制：printf如何输出到屏幕 输入处理：键盘按键如何被捕获和处理 进程管理：操作系统如何调度和管理进程 软硬件接口：软件与硬件的交互方式   应聘技能提升：操作系统知识是嵌入式开发、固件开发、芯片运行时等岗位的核心要求，可以作为简历上的项目备战招聘。  系统设计思维培养：操作系统是典型的系统设计课程，我们需要了解其中的系统设计思想，为解决复杂问题提供思路。   本文通过分析按下键盘回车键后的完整执行流程，展示xv6的中...</div></div></div></a><a class="pagination-related" href="/2026/Q1/operating-system-riscv-plic/" title="【操作系统】RISC-V PLIC总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">【操作系统】RISC-V PLIC总结</div></div><div class="info-2"><div class="info-item-1">本文是对【操作系统】xv6操作系统中按下键盘回车后发生的事情一文的补充阅读。如果你对PLIC（Platform-Level Interrupt Controller，平台级中断控制器）感到困惑，不妨先阅读这篇文章，了解PLIC的基本概念和工作原理。 什么是PLIC？在现代计算机系统中，CPU需要与各种外部设备（如键盘、鼠标、硬盘、网络卡等）进行通信。这些设备往往需要主动向CPU报告某些事件，比如键盘被按下、数据传输完成等。为了实现这种主动通知，设备会发出中断信号。 然而，在一个复杂的系统中，可能有数十甚至数百个设备同时发出中断请求。如果所有中断信号都直接涌向CPU，会导致混乱。因此，需要一个专门的硬件来管理和协调这些中断请求。这个硬件就是PLIC（Platform-Level Interrupt Controller，平台级中断控制器）。 通俗地理解，PLIC就像公司的秘书，中断目标就像公司的老板，而外部中断请求就像要拜访老板的访客。由于访客众多，如果没有处理就让他们全挤在老板办公室，会非常嘈杂。于是，老板聘请了一个秘书，规定所有访客都要在秘书那里登记。秘书会根据访客的重要性排序...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TDppy</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TDppy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/TDppy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2287015934@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如何呢，又能怎。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#memlayout-h"><span class="toc-number">2.</span> <span class="toc-text">memlayout.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.1.</span> <span class="toc-text">1. 物理内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E5%AF%84%E5%AD%98%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. 设备寄存器定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UART-%E4%B8%B2%E5%8F%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">UART 串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtIO-%E7%A3%81%E7%9B%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">VirtIO 磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLINT-%E6%A0%B8%E5%BF%83%E6%9C%AC%E5%9C%B0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">CLINT (核心本地中断控制器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%AF%94%E8%BE%83%E5%AF%84%E5%AD%98%E5%99%A8-CLINT-MTIMECMP"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">定时器比较寄存器 (CLINT_MTIMECMP)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.3.1.2.</span> <span class="toc-text">宏定义解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.3.1.3.</span> <span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8-CLINT-MTIME"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">全局定时器寄存器 (CLINT_MTIME)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">2.2.3.2.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.2.3.2.2.</span> <span class="toc-text">宏定义解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.3.2.3.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">定时器中断工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PLIC-%E5%B9%B3%E5%8F%B0%E7%BA%A7%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">PLIC (平台级中断控制器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%98%E5%85%88%E7%BA%A7%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84-PLIC-PRIORITY"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">1. 优先级寄存器组 (PLIC_PRIORITY)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BE%85%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-PLIC-PENDING"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2. 待处理中断寄存器 (PLIC_PENDING)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">3. 中断使能寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD-PLIC-MENABLE"><span class="toc-number">2.2.4.3.1.</span> <span class="toc-text">3.1 机器模式中断使能 (PLIC_MENABLE)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%9B%91%E7%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD-PLIC-SENABLE"><span class="toc-number">2.2.4.3.2.</span> <span class="toc-text">3.2 监管者模式中断使能 (PLIC_SENABLE)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%88%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">4. 优先级阈值寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%88%E5%80%BC-PLIC-MPRIORITY"><span class="toc-number">2.2.4.4.1.</span> <span class="toc-text">4.1 机器模式优先级阈值 (PLIC_MPRIORITY)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E7%9B%91%E7%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%88%E5%80%BC-PLIC-SPRIORITY"><span class="toc-number">2.2.4.4.2.</span> <span class="toc-text">4.2 监管者模式优先级阈值 (PLIC_SPRIORITY)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%AD%E6%96%AD%E8%AE%A4%E9%A2%86%E5%92%8C%E5%AE%8C%E6%88%90%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">5. 中断认领和完成寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E8%AE%A4%E9%A2%86-PLIC-MCLAIM"><span class="toc-number">2.2.4.5.1.</span> <span class="toc-text">5.1 机器模式中断认领 (PLIC_MCLAIM)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E7%9B%91%E7%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E8%AE%A4%E9%A2%86-PLIC-SCLAIM"><span class="toc-number">2.2.4.5.2.</span> <span class="toc-text">5.2 监管者模式中断认领 (PLIC_SCLAIM)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PLIC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">PLIC 工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.5.</span> <span class="toc-text">3. 内核内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%8A%E9%99%90"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">内核基地址和物理内存上限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">特殊内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Trampoline-%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.2.5.2.1.</span> <span class="toc-text">1. Trampoline 页面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">2.2.5.2.2.</span> <span class="toc-text">2. 内核栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Trapframe"><span class="toc-number">2.2.5.2.3.</span> <span class="toc-text">3. Trapframe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.6.</span> <span class="toc-text">4. 用户内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BE%9D%E8%B5%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">关键依赖定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%EF%BC%88%E6%9D%A5%E8%87%AA-riscv-h%EF%BC%89"><span class="toc-number">2.2.6.1.1.</span> <span class="toc-text">页面大小相关（来自 riscv.h）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8A%E9%99%90%EF%BC%88%E6%9D%A5%E8%87%AA-riscv-h%EF%BC%89"><span class="toc-number">2.2.6.1.2.</span> <span class="toc-text">虚拟地址空间上限（来自 riscv.h）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">内存布局设计特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">与其他文件的关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#riscv-h"><span class="toc-number">3.</span> <span class="toc-text">riscv.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1. 文件概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-CSR-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">2. 控制状态寄存器 (CSR) 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%86%99"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 核心寄存器读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%8E%A9%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 寄存器位掩码定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">3. 内存分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%A1%B5%E9%9D%A2%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 页面基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%A1%B5%E8%A1%A8%E9%A1%B9-PTE-%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 页表项 (PTE) 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A1%B5%E8%A1%A8%E7%B4%A2%E5%BC%95%E6%8F%90%E5%8F%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 页表索引提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 虚拟地址空间限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">4. 中断控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">3.5.</span> <span class="toc-text">5. 寄存器直接访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">6. 地址转换辅助函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">3.7.</span> <span class="toc-text">7. 类型定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defs-h"><span class="toc-number">4.</span> <span class="toc-text">defs.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">1. 文件概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">2. 结构体前向声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.</span> <span class="toc-text">3. 函数原型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9D%97%E8%AE%BE%E5%A4%87-I-O-bio-c"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 块设备 I&#x2F;O (bio.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8E%A7%E5%88%B6%E5%8F%B0-console-c"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 控制台 (console.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C-exec-c"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 进程执行 (exec.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-fs-c-file-c-pipe-c"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.4 文件系统 (fs.c, file.c, pipe.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-kalloc-c-vm-c"><span class="toc-number">4.3.5.</span> <span class="toc-text">3.5 内存管理 (kalloc.c, vm.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-proc-c"><span class="toc-number">4.3.6.</span> <span class="toc-text">3.6 进程管理 (proc.c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">4.3.7.</span> <span class="toc-text">3.7 其他核心模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%9A%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.</span> <span class="toc-text">4. 通用宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95-LAB-NET"><span class="toc-number">4.5.</span> <span class="toc-text">5. 网络扩展 (LAB_NET)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">4.6.</span> <span class="toc-text">6. 作用与意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#types-h"><span class="toc-number">5.</span> <span class="toc-text">types.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#param-h"><span class="toc-number">6.</span> <span class="toc-text">param.h</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/Q1/operating-system-riscv-plic/" title="【操作系统】RISC-V PLIC总结">【操作系统】RISC-V PLIC总结</a><time datetime="2026-01-18T15:25:18.000Z" title="发表于 2026-01-18 15:25:18">2026-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/Q1/hello-world/" title="欢迎来到潘业成的博客">欢迎来到潘业成的博客</a><time datetime="2026-01-12T00:00:00.000Z" title="发表于 2026-01-12 00:00:00">2026-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/Q1/operating-system-what-happens-after-pressing-enter-in-xv6-operating-system/" title="【操作系统】xv6操作系统中按下键盘回车后发生的事情">【操作系统】xv6操作系统中按下键盘回车后发生的事情</a><time datetime="2026-01-10T11:58:18.000Z" title="发表于 2026-01-10 11:58:18">2026-01-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/Q1/operating-system-hand-write-xv6-operating-system-types-h-param-h-memlayout-h-riscv-h-defs-h-header-file-analysis/" title="【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析">【操作系统】手撸xv6操作系统——types.h_param.h_memlayout.h_riscv.h_defs.h头文件解析</a><time datetime="2026-01-06T23:02:58.000Z" title="发表于 2026-01-06 23:02:58">2026-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/Q4/operating-system-hand-write-xv6-operating-system-entry-s-and-start-c-analysis/" title="【操作系统】手撸xv6操作系统——entry.S和start.c解析">【操作系统】手撸xv6操作系统——entry.S和start.c解析</a><time datetime="2025-12-30T15:57:42.000Z" title="发表于 2025-12-30 15:57:42">2025-12-30</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By TDppy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>